name: üöÄ Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'auto'
        type: choice
        options:
        - auto
        - patch
        - minor
        - major
      prerelease:
        description: 'Create prerelease'
        required: false
        default: false
        type: boolean
      dry_run:
        description: 'Dry run (no actual release)'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  pull-requests: write
  id-token: write
  models: read

jobs:
  # Job 1: Validate and prepare release
  validate:
    name: üîç Validate Release
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      current_version: ${{ steps.version.outputs.current_version }}
      next_version: ${{ steps.version.outputs.next_version }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üêç Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: üì¶ Install release dependencies
        run: |
          pip install --upgrade pip
          pip install -e .[build,dev]

      - name: üîç Check if release is needed
        id: check
        run: |
          echo "üîç Checking release requirements..."
          echo "Input - Release Type: ${{ github.event.inputs.release_type }}"
          echo "Input - Prerelease: ${{ github.event.inputs.prerelease }}"
          echo "Input - Dry Run: ${{ github.event.inputs.dry_run }}"
          
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "üß™ Dry run mode - proceeding with validation"
          else
            # Check if there are commits since last release that warrant a release
            if [ "${{ github.event.inputs.release_type }}" != "auto" ]; then
              # Force release when specific type is selected
              echo "should_release=true" >> $GITHUB_OUTPUT
              echo "‚úÖ Forced release type: ${{ github.event.inputs.release_type }}"
            else
              # Check semantic-release to see if a release is warranted
              echo "üîç Checking conventional commits for release..."
              
              if semantic-release version --print --no-commit --no-tag --no-push --no-vcs-release >/dev/null 2>&1; then
                echo "should_release=true" >> $GITHUB_OUTPUT
                echo "‚úÖ New release is needed based on commit history"
              else
                echo "should_release=false" >> $GITHUB_OUTPUT
                echo "‚ÑπÔ∏è No new release needed based on commit history"
                echo "üí° To force a release, select a specific release type (patch/minor/major)"
              fi
            fi
          fi

      - name: üìã Get version information
        id: version
        if: steps.check.outputs.should_release == 'true'
        run: |
          echo "üìä Getting version information..."
          
          # Get current version from pyproject.toml
          current=$(python3 -c "
          import toml
          try:
              data = toml.load('pyproject.toml')
              print(data['project']['version'])
          except Exception as e:
              print('Error reading version:', e, file=sys.stderr)
              exit(1)
          ")
          echo "current_version=$current" >> $GITHUB_OUTPUT
          echo "üìä Current version: $current"
          
          # Get next version based on release type
          echo "üî¢ Calculating next version..."
          if [ "${{ github.event.inputs.release_type }}" != "auto" ]; then
            echo "Using specified release type: ${{ github.event.inputs.release_type }}"
            if next=$(semantic-release version --print --no-commit --no-tag --no-push --no-vcs-release --${{ github.event.inputs.release_type }} 2>/dev/null); then
              echo "next_version=$next" >> $GITHUB_OUTPUT
              echo "üìä Next version: $next"
            else
              echo "‚ö†Ô∏è Failed to calculate next version, using current"
              echo "next_version=$current" >> $GITHUB_OUTPUT
              echo "üìä Next version: $current (fallback)"
            fi
          else
            echo "Using automatic versioning based on commits"
            if next=$(semantic-release version --print --no-commit --no-tag --no-push --no-vcs-release 2>/dev/null); then
              echo "next_version=$next" >> $GITHUB_OUTPUT
              echo "üìä Next version: $next"
            else
              echo "‚ö†Ô∏è No version bump needed, using current"
              echo "next_version=$current" >> $GITHUB_OUTPUT  
              echo "üìä Next version: $current (no change)"
            fi
          fi

  # Job 2: Build executables for multiple platforms (optional - doesn't fail release)
  build:
    name: üèóÔ∏è Build Executables
    needs: validate
    if: needs.validate.outputs.should_release == 'true'
    continue-on-error: true  # Don't fail the workflow if builds fail
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        include:
          - os: ubuntu-latest
            platform: linux
            artifact: aurora-linux
          - os: windows-latest
            platform: windows
            artifact: aurora-windows.exe
    runs-on: ${{ matrix.os }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üêç Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: üîß Install system dependencies (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y portaudio19-dev python3-dev gcc build-essential

      - name: üì¶ Install build dependencies
        run: |
          pip install --upgrade pip
          # Install runtime dependencies needed for Piper TTS and other components
          pip install -e .[runtime,build,torch-cpu]

      - name: üèóÔ∏è Build executable
        run: |
          # Use correct build.py syntax - no --platform option exists
          python scripts/build.py --target exe --clean
        timeout-minutes: 30
        continue-on-error: true  # Allow individual builds to fail

      - name: üìÅ Prepare artifacts
        shell: bash
        run: |
          mkdir -p artifacts
          
          # Check what was actually built
          echo "üìÇ Checking dist directory:"
          ls -la dist/ || echo "No dist directory found"
          
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            if [ -f "dist/Aurora.exe" ]; then
              echo "‚úÖ Found Windows executable"
              cp dist/Aurora.exe artifacts/aurora-windows.exe
              # Create portable package
              mkdir -p artifacts/aurora-windows
              cp dist/Aurora.exe artifacts/aurora-windows/
              [ -f "readme.md" ] && cp readme.md artifacts/aurora-windows/
              [ -f "README.md" ] && cp README.md artifacts/aurora-windows/
              [ -f "LICENSE" ] && cp LICENSE artifacts/aurora-windows/
              cd artifacts && zip -r aurora-windows-portable.zip aurora-windows/
            else
              echo "‚ùå Windows executable not found"
              exit 1
            fi
          else
            if [ -f "dist/Aurora" ]; then
              echo "‚úÖ Found Linux executable"
              cp dist/Aurora artifacts/aurora-linux
              chmod +x artifacts/aurora-linux
              # Create portable package
              mkdir -p artifacts/aurora-linux
              cp dist/Aurora artifacts/aurora-linux/aurora
              [ -f "readme.md" ] && cp readme.md artifacts/aurora-linux/
              [ -f "README.md" ] && cp README.md artifacts/aurora-linux/
              [ -f "LICENSE" ] && cp LICENSE artifacts/aurora-linux/
              cd artifacts && tar -czf aurora-linux-portable.tar.gz aurora-linux/
            else
              echo "‚ùå Linux executable not found"
              exit 1
            fi
          fi
          
          echo "üì¶ Prepared artifacts:"
          ls -la artifacts/

      - name: üì§ Upload artifacts
        uses: actions/upload-artifact@v4
        if: success()  # Only upload if build succeeded
        with:
          name: ${{ matrix.artifact }}
          path: artifacts/
          retention-days: 30

  # Job 3: Generate AI-powered release summary
  generate-summary:
    name: ü§ñ Generate Release Summary
    needs: validate
    if: needs.validate.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    outputs:
      release_summary: ${{ steps.ai-summary.outputs.summary }}
      changelog_preview: ${{ steps.changelog.outputs.preview }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üêç Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Install dependencies
        run: |
          pip install --upgrade pip
          pip install python-semantic-release[changelog] requests

      - name: üìã Generate changelog preview
        id: changelog
        run: |
          preview=$(semantic-release changelog --print --no-commit --no-tag --no-push --no-vcs-release 2>/dev/null || echo "No changelog available")
          # Escape newlines for GitHub output
          preview_escaped=$(echo "$preview" | sed ':a;N;$!ba;s/\n/\\n/g')
          echo "preview=$preview_escaped" >> $GITHUB_OUTPUT

      - name: ü§ñ Generate AI release summary
        id: ai-summary
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ü§ñ Starting AI release summary generation..."
          
          # Get recent commits for context
          commits=$(git log --oneline --since="$(git describe --tags --abbrev=0 2>/dev/null || echo '1 month ago')" --pretty=format:"- %s (%an)" | head -20)
          
          # Debug: show what commits we found
          echo "üìã Found commits:"
          echo "$commits"
          
          # Create a proper JSON file with escaped content
          python3 << 'EOF'
          import json
          import os
          import sys
          
          commits_text = """$commits"""
          
          # Create the request payload
          payload = {
              "messages": [
                  {
                      "role": "system",
                      "content": "You are a technical writer specializing in release notes for open-source software. Generate a concise, professional release summary that highlights key features, improvements, and fixes. Focus on user-facing changes and technical improvements. Use markdown formatting."
                  },
                  {
                      "role": "user", 
                      "content": f"Generate a release summary for Aurora Voice Assistant version ${{ needs.validate.outputs.next_version }}. Here are the recent commits:\n\n{commits_text}\n\nProject context: Aurora is a Python-based intelligent voice assistant for local automation and productivity. It uses real-time speech-to-text, LLMs, and various productivity tools in a modular, privacy-focused architecture.\n\nGenerate a 2-3 paragraph summary highlighting the most important changes for users."
                  }
              ],
              "model": "gpt-4o-mini",
              "max_tokens": 500,
              "temperature": 0.7
          }
          
          # Write to file
          with open('prompt.json', 'w') as f:
              json.dump(payload, f, indent=2)
              
          print("‚úÖ Created prompt.json file")
          EOF
          
          # Debug: show the created file
          echo "üìÑ Created prompt file:"
          cat prompt.json
          
          # Initialize fallback summary
          fallback_summary="üöÄ **Aurora Voice Assistant ${{ needs.validate.outputs.next_version }}**

          This release includes various improvements and updates to Aurora's voice assistant capabilities.

          **Recent Changes:**
          $commits

          See the detailed changelog below for specific technical changes and improvements."
          
          # Try GitHub Models API with correct endpoint
          echo "üåê Calling GitHub Models API..."
          if response=$(curl -s -w "%{http_code}" -o response.json "https://models.inference.ai.azure.com/chat/completions" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -d @prompt.json 2>/dev/null); then
            
            http_code="${response: -3}"
            echo "üìä HTTP Response Code: $http_code"
            
            if [ "$http_code" = "200" ]; then
              echo "‚úÖ API call successful, parsing response..."
              
              # Extract summary from response
              if summary=$(python3 -c "
              import json, sys
              try:
                  with open('response.json', 'r') as f:
                      data = json.load(f)
                  content = data['choices'][0]['message']['content']
                  print(content)
              except Exception as e:
                  print('Fallback due to parsing error: ' + str(e), file=sys.stderr)
                  sys.exit(1)
              " 2>/dev/null); then
                echo "‚úÖ Successfully extracted AI summary"
                # Use proper GitHub Actions multiline output
                echo "summary<<EOF" >> $GITHUB_OUTPUT
                echo "$summary" >> $GITHUB_OUTPUT
                echo "EOF" >> $GITHUB_OUTPUT
              else
                echo "‚ö†Ô∏è Failed to parse API response, using fallback"
                echo "üìÑ Response content:"
                cat response.json
                echo "summary<<EOF" >> $GITHUB_OUTPUT
                echo "$fallback_summary" >> $GITHUB_OUTPUT
                echo "EOF" >> $GITHUB_OUTPUT
              fi
            else
              echo "‚ùå API call failed with HTTP $http_code"
              echo "üìÑ Error response:"
              cat response.json
              echo "summary<<EOF" >> $GITHUB_OUTPUT
              echo "$fallback_summary" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ùå GitHub Models API unavailable or network error"
            echo "summary<<EOF" >> $GITHUB_OUTPUT
            echo "$fallback_summary" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
          
          echo "üéâ AI summary generation completed"

  # Job 4: Create release (independent of build success)
  release:
    name: üéâ Create Release
    needs: [validate, generate-summary]
    if: needs.validate.outputs.should_release == 'true' && github.event.inputs.dry_run != 'true'
    runs-on: ubuntu-latest
    outputs:
      release_tag: ${{ steps.semantic-release.outputs.tag }}
      release_url: ${{ steps.semantic-release.outputs.url }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üêç Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Install semantic-release
        run: |
          pip install --upgrade pip
          pip install python-semantic-release[changelog]

      - name: üéØ Run semantic release
        id: semantic-release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Run semantic-release
          if [ "${{ github.event.inputs.release_type }}" != "auto" ]; then
            if [ "${{ github.event.inputs.prerelease }}" = "true" ]; then
              semantic-release version --${{ github.event.inputs.release_type }} --prerelease
            else
              semantic-release version --${{ github.event.inputs.release_type }}
            fi
          else
            if [ "${{ github.event.inputs.prerelease }}" = "true" ]; then
              semantic-release version --prerelease
            else
              semantic-release version
            fi
          fi
          
          # Capture outputs
          tag=$(git describe --tags --exact-match HEAD 2>/dev/null || echo "")
          if [ -n "$tag" ]; then
            echo "tag=$tag" >> $GITHUB_OUTPUT
            echo "url=https://github.com/${{ github.repository }}/releases/tag/$tag" >> $GITHUB_OUTPUT
          fi

      - name: üìù Update release with AI summary
        if: steps.semantic-release.outputs.tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get current release
          tag="${{ steps.semantic-release.outputs.tag }}"
          
          echo "üéØ Updating release $tag with enhanced notes..."
          
          # Create enhanced release notes with proper escaping
          cat << 'EOF' > enhanced_notes.md
          ## ü§ñ AI-Generated Release Summary
          
          ${{ needs.generate-summary.outputs.release_summary }}
          
          ## üìù Detailed Changelog
          
          ${{ needs.generate-summary.outputs.changelog_preview }}
          
          ## üì¶ Installation Options
          
          ### Option 1: Download Pre-built Executables
          EOF
          
          # Add build status info
          if [ "${{ needs.build.result }}" = "success" ]; then
            cat << 'EOF' >> enhanced_notes.md
          ‚úÖ **Executables available below:**
          - **Linux**: Download `aurora-linux-portable.tar.gz` 
          - **Windows**: Download `aurora-windows-portable.zip`
          
          Simply download, extract, and run the executable for your platform.
          EOF
          else
            cat << 'EOF' >> enhanced_notes.md
          ‚ö†Ô∏è **Pre-built executables not available** for this release due to build issues.
          Please use one of the installation methods below.
          EOF
          fi
          
          # Add installation methods
          cat << 'EOF' >> enhanced_notes.md
          
          ### Option 2: Install via pip (recommended)
          ```bash
          pip install aurora-voice-assistant
          ```
          
          ### Option 3: Install from Source
          ```bash
          git clone https://github.com/$GITHUB_REPOSITORY.git
          cd aurora
          git checkout $tag
          pip install -e .[full-third-party]
          ```
          
          ### Option 4: Quick Setup Script
          ```bash
          git clone https://github.com/$GITHUB_REPOSITORY.git
          cd aurora
          ./setup.sh  # Interactive setup with hardware detection
          ```
          
          ## ‚öôÔ∏è System Requirements
          
          - **Python**: 3.9-3.11 (‚ö†Ô∏è Python 3.12+ not supported due to dependency conflicts)
          - **OS**: Linux, Windows, macOS
          - **Audio**: Input/output devices (microphone and speakers)
          - **Memory**: 4GB+ RAM (8GB+ recommended for local models)
          - **Storage**: 2GB+ free space
          - **Network**: Required for API-based models (optional for local models)
          
          ## üöÄ Quick Start
          
          1. **Install Aurora** using any method above
          2. **Run setup**: `./setup.sh` (interactive) or configure `config.json` manually
          3. **Start Aurora**: `python main.py`
          4. **Say "Hey Jarvis"** to activate voice commands
          
          For detailed installation instructions, see [INSTALL.md](https://github.com/$GITHUB_REPOSITORY/blob/main/docs/INSTALL.md).
          
          ---
          
          ü§ñ *This release was automatically generated using [python-semantic-release](https://python-semantic-release.readthedocs.io/) with AI-powered summaries via GitHub Models.*
          EOF
          
          echo "üìÑ Generated enhanced release notes:"
          cat enhanced_notes.md
          
          # Update release with enhanced notes
          echo "üìù Updating GitHub release..."
          if gh release edit "$tag" --notes-file enhanced_notes.md; then
            echo "‚úÖ Successfully updated release notes"
          else
            echo "‚ùå Failed to update release notes"
            exit 1
          fi

  # Job 5: Upload release artifacts (only if builds succeeded)
  upload-artifacts:
    name: üì¶ Upload Release Artifacts  
    needs: [validate, build, release]
    if: needs.validate.outputs.should_release == 'true' && github.event.inputs.dry_run != 'true' && needs.release.outputs.release_tag && needs.build.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: üì• Download Linux artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true  # Don't fail if artifacts don't exist
        with:
          name: aurora-linux
          path: ./linux-artifacts

      - name: üì• Download Windows artifacts  
        uses: actions/download-artifact@v4
        continue-on-error: true  # Don't fail if artifacts don't exist
        with:
          name: aurora-windows.exe
          path: ./windows-artifacts

      - name: üì§ Upload artifacts to release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          tag="${{ needs.release.outputs.release_tag }}"
          
          # Upload Linux artifacts (if they exist)
          if [ -f "./linux-artifacts/aurora-linux-portable.tar.gz" ]; then
            echo "üì¶ Uploading Linux portable package..."
            gh release upload "$tag" "./linux-artifacts/aurora-linux-portable.tar.gz" --clobber || echo "‚ö†Ô∏è Failed to upload Linux portable package"
          else
            echo "‚ÑπÔ∏è Linux portable package not found - skipping"
          fi
          
          if [ -f "./linux-artifacts/aurora-linux" ]; then
            echo "üì¶ Uploading Linux executable..."
            gh release upload "$tag" "./linux-artifacts/aurora-linux" --clobber || echo "‚ö†Ô∏è Failed to upload Linux executable"
          else
            echo "‚ÑπÔ∏è Linux executable not found - skipping"
          fi
          
          # Upload Windows artifacts (if they exist)
          if [ -f "./windows-artifacts/aurora-windows-portable.zip" ]; then
            echo "üì¶ Uploading Windows portable package..."
            gh release upload "$tag" "./windows-artifacts/aurora-windows-portable.zip" --clobber || echo "‚ö†Ô∏è Failed to upload Windows portable package"
          else
            echo "‚ÑπÔ∏è Windows portable package not found - skipping"
          fi
          
          if [ -f "./windows-artifacts/aurora-windows.exe" ]; then
            echo "üì¶ Uploading Windows executable..."
            gh release upload "$tag" "./windows-artifacts/aurora-windows.exe" --clobber || echo "‚ö†Ô∏è Failed to upload Windows executable"
          else
            echo "‚ÑπÔ∏è Windows executable not found - skipping"
          fi

  # Job 6: Notify completion
  notify:
    name: üì¢ Notify Completion
    needs: [validate, build, generate-summary, release, upload-artifacts]
    if: always() && needs.validate.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: üìä Release Summary
        run: |
          echo "## üéâ Release Workflow Complete!"
          echo ""
          echo "### üìã Details:"
          echo "- **Previous Version**: ${{ needs.validate.outputs.current_version }}"
          echo "- **New Version**: ${{ needs.validate.outputs.next_version }}"
          echo "- **Release Type**: ${{ github.event.inputs.release_type }}"
          echo "- **Prerelease**: ${{ github.event.inputs.prerelease }}"
          echo "- **Dry Run**: ${{ github.event.inputs.dry_run }}"
          echo ""
          if [ "${{ needs.release.result }}" = "success" ]; then
            echo "- **Release URL**: ${{ needs.release.outputs.release_url }}"
            echo "- **Release Tag**: ${{ needs.release.outputs.release_tag }}"
          fi
          echo ""
          echo "### üèóÔ∏è Build Status:"
          echo "- **Build Job**: ${{ needs.build.result }}"
          if [ "${{ needs.build.result }}" = "success" ]; then
            echo "  ‚úÖ Executable builds completed successfully"
          elif [ "${{ needs.build.result }}" = "failure" ]; then
            echo "  ‚ö†Ô∏è Executable builds failed (release still created)"
          else
            echo "  ‚ÑπÔ∏è Build status: ${{ needs.build.result }}"
          fi
          echo ""
          echo "### ü§ñ AI Summary Generated:"
          echo "${{ needs.generate-summary.outputs.release_summary }}"

      - name: ‚ö†Ô∏è Workflow Failed
        if: failure()
        run: |
          echo "## ‚ùå Release Workflow Failed"
          echo ""
          echo "One or more jobs in the release workflow failed."
          echo "Please check the workflow logs for details."
          echo ""
          echo "### Job Status:"
          echo "- **Validate**: ${{ needs.validate.result }}"
          echo "- **Build**: ${{ needs.build.result }}" 
          echo "- **Generate Summary**: ${{ needs.generate-summary.result }}"
          echo "- **Release**: ${{ needs.release.result }}"
          echo "- **Upload Artifacts**: ${{ needs.upload-artifacts.result }}"
